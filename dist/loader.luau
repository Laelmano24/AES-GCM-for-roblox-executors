local a,b,c={AES={}},{CSPRNG={},Conversions={}},{ChaCha20=nil,Blake3=nil}do local d,e,f,g=64,32,64,64 local h,i,j,k,l,m=g*e,0x1,0x2,0x4,0x8,buffer.create(e)do local n={0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19}for o,p in ipairs(n)do buffer.writeu32(m,(o-1)*4,p)end end local function Compress(n,o,p,q,r,s)local t,u,v,w,x,y,z,A=buffer.readu32(n,0),buffer.readu32(n,4),buffer.readu32(n,8),buffer.readu32(n,12),buffer.readu32(n,16),buffer.readu32(n,20),buffer.readu32(n,24),buffer.readu32(n,28)local B,C,D,E,F,G,H,I,J,K,L,M,N=t,u,v,w,x,y,z,A,0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,p%(4294967296)local O,P,Q,R,S,T,U,V,W,X,Y,Z,_,aa,ab,ac,ad,ae,af,ag=(p-N)*(2.3283064365386963E-10),buffer.readu32(o,0),buffer.readu32(o,4),buffer.readu32(o,8),buffer.readu32(o,12),buffer.readu32(o,16),buffer.readu32(o,20),buffer.readu32(o,24),buffer.readu32(o,28),buffer.readu32(o,32),buffer.readu32(o,36),buffer.readu32(o,40),buffer.readu32(o,44),buffer.readu32(o,48),buffer.readu32(o,52),buffer.readu32(o,56),buffer.readu32(o,60),bit32.bxor,(bit32.lrotate)for ah=1,7 do B+=F+P N=af(ae(N,B),16)J+=N F=af(ae(F,J),20)B+=F+Q N=af(ae(N,B),24)J+=N F=af(ae(F,J),25)C+=G+R O=af(ae(O,C),16)K+=O G=af(ae(G,K),20)C+=G+S O=af(ae(O,C),24)K+=O G=af(ae(G,K),25)D+=H+T q=af(ae(q,D),16)L+=q H=af(ae(H,L),20)D+=H+U q=af(ae(q,D),24)L+=q H=af(ae(H,L),25)E+=I+V r=af(ae(r,E),16)M+=r I=af(ae(I,M),20)E+=I+W r=af(ae(r,E),24)M+=r I=af(ae(I,M),25)B+=G+X r=af(ae(r,B),16)L+=r G=af(ae(G,L),20)B+=G+Y r=af(ae(r,B),24)L+=r G=af(ae(G,L),25)C+=H+Z N=af(ae(N,C),16)M+=N H=af(ae(H,M),20)C+=H+_ N=af(ae(N,C),24)M+=N H=af(ae(H,M),25)D+=I+aa O=af(ae(O,D),16)J+=O I=af(ae(I,J),20)D+=I+ab O=af(ae(O,D),24)J+=O I=af(ae(I,J),25)E+=F+ac q=af(ae(q,E),16)K+=q F=af(ae(F,K),20)E+=F+ad q=af(ae(q,E),24)K+=q F=af(ae(F,K),25)if ah~=7 then ag=R R=S S=Z Z=aa aa=Y Y=_ _=U U=P P=ag ag=V V=T T=W W=ab ab=ac ac=ad ad=X X=Q Q=ag end end if s then local ah=buffer.create(f)buffer.writeu32(ah,0,ae(B,J))buffer.writeu32(ah,4,ae(C,K))buffer.writeu32(ah,8,ae(D,L))buffer.writeu32(ah,12,ae(E,M))buffer.writeu32(ah,16,ae(F,N))buffer.writeu32(ah,20,ae(G,O))buffer.writeu32(ah,24,ae(H,q))buffer.writeu32(ah,28,ae(I,r))buffer.writeu32(ah,32,ae(J,t))buffer.writeu32(ah,36,ae(K,u))buffer.writeu32(ah,40,ae(L,v))buffer.writeu32(ah,44,ae(M,w))buffer.writeu32(ah,48,ae(N,x))buffer.writeu32(ah,52,ae(O,y))buffer.writeu32(ah,56,ae(q,z))buffer.writeu32(ah,60,ae(r,A))return ah else local ah=buffer.create(e)buffer.writeu32(ah,0,ae(B,J))buffer.writeu32(ah,4,ae(C,K))buffer.writeu32(ah,8,ae(D,L))buffer.writeu32(ah,12,ae(E,M))buffer.writeu32(ah,16,ae(F,N))buffer.writeu32(ah,20,ae(G,O))buffer.writeu32(ah,24,ae(H,q))buffer.writeu32(ah,28,ae(I,r))return ah end end local function ProcessMessage(aa,ab,ac,ad)local ae,af,ag,ah=buffer.len(ac),buffer.create(h),0,buffer.create(e)buffer.copy(ah,0,aa,0,e)local n,o,p,q,r=0,0,0,i,buffer.create(d)for s=0,ae-d-1,d do buffer.copy(r,0,ac,s,d)local t=ab+q+p ah=Compress(ah,r,n,d,t)q=0 o+=1 if o==15 then p=j elseif o==16 then local u,v=ah,n+1 while v%2==0 do ag=ag-1 local w=buffer.create(e)buffer.copy(w,0,af,ag*e,e)local x=buffer.create(f)buffer.copy(x,0,w,0,e)buffer.copy(x,e,u,0,e)u=Compress(aa,x,0,d,ab+k)v=v/2 end buffer.copy(af,ag*e,u,0,e)ag=ag+1 buffer.copy(ah,0,aa,0,e)q=i n+=1 o=0 p=0 end end local s,t=ae==0 and 0 or((ae-1)%d+1),buffer.create(d)if s>0 then buffer.copy(t,0,ac,ae-s,s)end local u,v,w,x if n>0 then local y=ab+q+j local z=Compress(ah,t,n,s,y)for A=ag,2,-1 do local B=buffer.create(e)buffer.copy(B,0,af,(A-1)*e,e)local C=buffer.create(f)buffer.copy(C,0,B,0,e)buffer.copy(C,e,z,0,e)z=Compress(aa,C,0,d,ab+k)end u=aa local A=buffer.create(e)buffer.copy(A,0,af,0,e)v=buffer.create(f)buffer.copy(v,0,A,0,e)buffer.copy(v,e,z,0,e)w=d x=ab+l+k else u=ah v=t w=s x=ab+q+j+l end local y,z=buffer.create(ad),0 for A=0,ad//d do local B,C=Compress(u,v,A,w,x,true),math.min(d,ad-z)buffer.copy(y,z,B,0,C)z+=C if z>=ad then break end end return y end c.Blake3=function(aa,ab)return ProcessMessage(m,0,aa,ab or 32)end end do local aa,ab,ac,ad,ae,af,ag=4,64,16,12,16,32,buffer.create(16)do local ah={string.byte('expand 32-byte k',1,-1)}for d,e in ah do buffer.writeu8(ag,d-1,e)end end local ah=buffer.create(16)do local d={string.byte('expand 16-byte k',1,-1)}for e,f in d do buffer.writeu8(ah,e-1,f)end end local function ProcessBlock(d,e)local f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u=buffer.readu32(d,0),buffer.readu32(d,4),buffer.readu32(d,8),buffer.readu32(d,12),buffer.readu32(d,16),buffer.readu32(d,20),buffer.readu32(d,24),buffer.readu32(d,28),buffer.readu32(d,32),buffer.readu32(d,36),buffer.readu32(d,40),buffer.readu32(d,44),buffer.readu32(d,48),buffer.readu32(d,52),buffer.readu32(d,56),buffer.readu32(d,60)for v=1,e do local w=v%2==1 if w then f=bit32.bor(f+j,0)r=bit32.lrotate(bit32.bxor(r,f),16)n=bit32.bor(n+r,0)j=bit32.lrotate(bit32.bxor(j,n),12)f=bit32.bor(f+j,0)r=bit32.lrotate(bit32.bxor(r,f),8)n=bit32.bor(n+r,0)j=bit32.lrotate(bit32.bxor(j,n),7)g=bit32.bor(g+k,0)s=bit32.lrotate(bit32.bxor(s,g),16)o=bit32.bor(o+s,0)k=bit32.lrotate(bit32.bxor(k,o),12)g=bit32.bor(g+k,0)s=bit32.lrotate(bit32.bxor(s,g),8)o=bit32.bor(o+s,0)k=bit32.lrotate(bit32.bxor(k,o),7)h=bit32.bor(h+l,0)t=bit32.lrotate(bit32.bxor(t,h),16)p=bit32.bor(p+t,0)l=bit32.lrotate(bit32.bxor(l,p),12)h=bit32.bor(h+l,0)t=bit32.lrotate(bit32.bxor(t,h),8)p=bit32.bor(p+t,0)l=bit32.lrotate(bit32.bxor(l,p),7)i=bit32.bor(i+m,0)u=bit32.lrotate(bit32.bxor(u,i),16)q=bit32.bor(q+u,0)m=bit32.lrotate(bit32.bxor(m,q),12)i=bit32.bor(i+m,0)u=bit32.lrotate(bit32.bxor(u,i),8)q=bit32.bor(q+u,0)m=bit32.lrotate(bit32.bxor(m,q),7)else f=bit32.bor(f+k,0)u=bit32.lrotate(bit32.bxor(u,f),16)p=bit32.bor(p+u,0)k=bit32.lrotate(bit32.bxor(k,p),12)f=bit32.bor(f+k,0)u=bit32.lrotate(bit32.bxor(u,f),8)p=bit32.bor(p+u,0)k=bit32.lrotate(bit32.bxor(k,p),7)g=bit32.bor(g+l,0)r=bit32.lrotate(bit32.bxor(r,g),16)q=bit32.bor(q+r,0)l=bit32.lrotate(bit32.bxor(l,q),12)g=bit32.bor(g+l,0)r=bit32.lrotate(bit32.bxor(r,g),8)q=bit32.bor(q+r,0)l=bit32.lrotate(bit32.bxor(l,q),7)h=bit32.bor(h+m,0)s=bit32.lrotate(bit32.bxor(s,h),16)n=bit32.bor(n+s,0)m=bit32.lrotate(bit32.bxor(m,n),12)h=bit32.bor(h+m,0)s=bit32.lrotate(bit32.bxor(s,h),8)n=bit32.bor(n+s,0)m=bit32.lrotate(bit32.bxor(m,n),7)i=bit32.bor(i+j,0)t=bit32.lrotate(bit32.bxor(t,i),16)o=bit32.bor(o+t,0)j=bit32.lrotate(bit32.bxor(j,o),12)i=bit32.bor(i+j,0)t=bit32.lrotate(bit32.bxor(t,i),8)o=bit32.bor(o+t,0)j=bit32.lrotate(bit32.bxor(j,o),7)end end buffer.writeu32(d,0,buffer.readu32(d,0)+f)buffer.writeu32(d,4,buffer.readu32(d,4)+g)buffer.writeu32(d,8,buffer.readu32(d,8)+h)buffer.writeu32(d,12,buffer.readu32(d,12)+i)buffer.writeu32(d,16,buffer.readu32(d,16)+j)buffer.writeu32(d,20,buffer.readu32(d,20)+k)buffer.writeu32(d,24,buffer.readu32(d,24)+l)buffer.writeu32(d,28,buffer.readu32(d,28)+m)buffer.writeu32(d,32,buffer.readu32(d,32)+n)buffer.writeu32(d,36,buffer.readu32(d,36)+o)buffer.writeu32(d,40,buffer.readu32(d,40)+p)buffer.writeu32(d,44,buffer.readu32(d,44)+q)buffer.writeu32(d,48,buffer.readu32(d,48)+r)buffer.writeu32(d,52,buffer.readu32(d,52)+s)buffer.writeu32(d,56,buffer.readu32(d,56)+t)buffer.writeu32(d,60,buffer.readu32(d,60)+u)end local function InitializeState(d,e,f)local g,h=buffer.len(d),buffer.create(ac*aa)local i=g==32 and ag or ah buffer.copy(h,0,i,0,16)buffer.copy(h,16,d,0,math.min(g,16))if g==32 then buffer.copy(h,32,d,16,16)else buffer.copy(h,32,d,0,16)end buffer.writeu32(h,48,f)buffer.copy(h,52,e,0,12)return h end c.ChaCha20=function(d,e,f,g,h)if d==nil then error('Data cannot be nil',2)end if typeof(d)~='buffer'then error(`Data must be a buffer, got {typeof(d)}`,2)end if e==nil then error('Key cannot be nil',2)end if typeof(e)~='buffer'then error(`Key must be a buffer, got {typeof(e)}`,2)end local i=buffer.len(e)if i~=ae and i~=af then error(`Key must be {ae} or {af} bytes long, got {i} bytes`,2)end if f==nil then error('Nonce cannot be nil',2)end if typeof(f)~='buffer'then error(`Nonce must be a buffer, got {typeof(f)}`,2)end local j=buffer.len(f)if j~=ad then error(`Nonce must be exactly {ad} bytes long, got {j} bytes`,2)end if g then if typeof(g)~='number'then error(`Counter must be a number, got {typeof(g)}`,2)end if g<0 then error(`Counter cannot be negative, got {g}`,2)end if g~=math.floor(g)then error(`Counter must be an integer, got {g}`,2)end if g>=4294967296 then error(`Counter must be less than 2^32, got {g}`,2)end end if h then if typeof(h)~='number'then error(`Rounds must be a number, got {typeof(h)}`,2)end if h<=0 then error(`Rounds must be positive, got {h}`,2)end if h~=math.floor(h)then error(`Rounds must be an integer, got {h}`,2)end if h%2~=0 then error(`Rounds must be even, got {h}`,2)end end local k,l,m=g or 1,h or 20,buffer.len(d)if m==0 then return buffer.create(0)end local n,o,p,q=buffer.create(m),0,InitializeState(e,f,k),buffer.create(64)buffer.copy(q,0,p,0)while o<m do ProcessBlock(p,l)local r=math.min(ab,m-o)for s=0,r-1 do local t,u=buffer.readu8(d,o+s),buffer.readu8(p,s)buffer.writeu8(n,o+s,bit32.bxor(t,u))end o+=r k+=1 buffer.copy(p,0,q,0)buffer.writeu32(p,48,k)end return n end end do local aa=buffer.create(512)do local ab='0123456789abcdef'for ac=0,255 do local ad,ae=bit32.rshift(ac,4),ac%16 local af,ag=string.byte(ab,ad+1),string.byte(ab,ae+1)local ah=af+bit32.lshift(ag,8)buffer.writeu16(aa,ac*2,ah)end end local ab=buffer.create(131072)do for ac=0,255 do for ad=0,255 do local ae,af=0,0 if ac>=48 and ac<=57 then ae=ac-48 elseif ac>=65 and ac<=70 then ae=ac-55 elseif ac>=97 and ac<=102 then ae=ac-87 else ae=0 end if ad>=48 and ad<=57 then af=ad-48 elseif ad>=65 and ad<=70 then af=ad-55 elseif ad>=97 and ad<=102 then af=ad-87 else af=0 end local ag,ah=bit32.lshift(ae,4)+af,bit32.lshift(ad,8)+ac buffer.writeu16(ab,ah*2,ag)end end end local ac={}function ac.ToHex(ad)local ae=buffer.len(ad)local af,ag,ah,d=buffer.create(ae*2),aa,ae%8,0 for e=0,ae-ah-1,8 do local f,g,h,i,j,k,l,m=buffer.readu16(ag,buffer.readu8(ad,e)*2),buffer.readu16(ag,buffer.readu8(ad,e+1)*2),buffer.readu16(ag,buffer.readu8(ad,e+2)*2),buffer.readu16(ag,buffer.readu8(ad,e+3)*2),buffer.readu16(ag,buffer.readu8(ad,e+4)*2),buffer.readu16(ag,buffer.readu8(ad,e+5)*2),buffer.readu16(ag,buffer.readu8(ad,e+6)*2),buffer.readu16(ag,buffer.readu8(ad,e+7)*2)buffer.writeu16(af,d,f)buffer.writeu16(af,d+2,g)buffer.writeu16(af,d+4,h)buffer.writeu16(af,d+6,i)buffer.writeu16(af,d+8,j)buffer.writeu16(af,d+10,k)buffer.writeu16(af,d+12,l)buffer.writeu16(af,d+14,m)d+=16 end for e=ae-ah,ae-1 do local f=buffer.readu16(ag,buffer.readu8(ad,e)*2)buffer.writeu16(af,d,f)d+=2 end return buffer.tostring(af)end function ac.FromHex(ad)local ae=if type(ad)=='string'then buffer.fromstring(ad)else ad local af=buffer.len(ae)if af%2~=0 then error(`Length must be even, got {af}`)end local ag,ah,d,e=buffer.create(bit32.rshift(af,1)),af%16,0,ab for f=0,af-ah-1,16 do local g,h,i,j,k,l,m,n=buffer.readu16(ae,f),buffer.readu16(ae,f+2),buffer.readu16(ae,f+4),buffer.readu16(ae,f+6),buffer.readu16(ae,f+8),buffer.readu16(ae,f+10),buffer.readu16(ae,f+12),buffer.readu16(ae,f+14)local o,p,q,r,s,t,u,v=buffer.readu16(e,g*2),buffer.readu16(e,h*2),buffer.readu16(e,i*2),buffer.readu16(e,j*2),buffer.readu16(e,k*2),buffer.readu16(e,l*2),buffer.readu16(e,m*2),buffer.readu16(e,n*2)local w,x=bit32.lshift(r,24)+bit32.lshift(q,16)+bit32.lshift(p,8)+o,bit32.lshift(v,24)+bit32.lshift(u,16)+bit32.lshift(t,8)+s buffer.writeu32(ag,d,w)buffer.writeu32(ag,d+4,x)d+=8 end for f=af-ah,af-1,2 do local g=buffer.readu16(ae,f)local h=buffer.readu16(e,g*2)buffer.writeu8(ag,d,h)d+=1 end return ag end b.Conversions=ac end do local aa,ab,ac,ad=64,32,12,{BlockExpansion=true,SizeTarget=2048,RekeyAfter=1024,Key=buffer.create(0),Nonce=buffer.create(0),Buffer=buffer.create(0),Counter=0,BufferPosition=0,BufferSize=0,BytesLeft=0,EntropyProviders={}}local ae,af,ag=buffer.create(aa),math.max(math.floor(ad.RekeyAfter),2),math.clamp(math.floor(ad.SizeTarget),64,4294967295)local function Reset()ad.Key=buffer.create(0)ad.Nonce=buffer.create(0)ad.Buffer=buffer.create(0)ad.Counter=0 ad.BufferPosition=0 ad.BufferSize=0 end local function GatherEntropy(ah)local d,e=buffer.create(1024),0 local function WriteToBuffer(f)local g=buffer.len(f)buffer.copy(d,e,f,0,g)e+=g end local f=1.234 if tick then f=tick()local g=buffer.create(8)buffer.writef64(g,0,f)WriteToBuffer(g)end local g,h=os.clock(),buffer.create(8)buffer.writef64(h,0,g)WriteToBuffer(h)local i,j=os.time(),buffer.create(8)buffer.writeu32(j,0,i%0x100000000)buffer.writeu32(j,4,math.floor(i/0x100000000))WriteToBuffer(j)local k=5.678 if DateTime then k=DateTime.now().UnixTimestampMillis local l=buffer.create(8)buffer.writef64(l,0,k)WriteToBuffer(l)local m=buffer.create(16)buffer.writef32(m,0,k/1000)buffer.writef32(m,4,(k%1000)/100)buffer.writef32(m,8,k/86400000)buffer.writef32(m,12,(k*0.001)%1)WriteToBuffer(m)else WriteToBuffer(buffer.create(24))end local l=buffer.create(16)buffer.writef32(l,0,g/100)buffer.writef32(l,4,f/1000)buffer.writef32(l,8,(g*12345.6789)%1)buffer.writef32(l,12,(f*98765.4321)%1)WriteToBuffer(l)local m=buffer.create(32)for n=0,7 do local o,p,q,r=math.noise(g+n,i+n,g+i+n),math.noise(f+n*0.1,k*0.0001+n,g*1.5+n),math.noise(i*0.01+n,g+k*0.001,f+n*2),math.noise(k*0.00001+n,i+g+n,f*0.1+n)buffer.writef32(m,n*4,o+p+q+r)end WriteToBuffer(m)local n=buffer.create(32)for o=0,7 do local p,q,r=os.clock(),0,50+(o*25)for s=1,r do q+=s*s+math.sin(s/10)*math.cos(s/7)end local s=os.clock()local t=s-p buffer.writef32(n,o*4,t*1000000)end WriteToBuffer(n)local o=buffer.create(24)for p=0,5 do local q=os.clock()for r=1,20 do buffer.create(64+r)end local r=os.clock()buffer.writef32(o,p*4,(r-q)*10000000)end WriteToBuffer(o)local p,q=math.floor(f*1000000),buffer.create(8)buffer.writeu32(q,0,p%0x100000000)buffer.writeu32(q,4,math.floor(p/0x100000000))WriteToBuffer(q)if game then if game.JobId and#game.JobId>0 then local r=buffer.fromstring(game.JobId)WriteToBuffer(r)end if game.PlaceId then local r=buffer.create(8)buffer.writeu32(r,0,game.PlaceId%0x100000000)buffer.writeu32(r,4,math.floor(game.PlaceId/0x100000000))WriteToBuffer(r)end if workspace and workspace.DistributedGameTime then local r=buffer.create(8)buffer.writef64(r,0,workspace.DistributedGameTime)WriteToBuffer(r)local s,t=math.floor(workspace.DistributedGameTime*1000000),buffer.create(8)buffer.writeu32(t,0,s%0x100000000)buffer.writeu32(t,4,math.floor(s/0x100000000))WriteToBuffer(t)end end local r=buffer.create(128)for s=0,7 do local t,u,v,w={},function()end,buffer.create(0),newproxy()local x,y,z,A,B,C,D,E,F=string.gsub(tostring(t),'table: ',''),string.gsub(tostring(u),'function: ',''),string.gsub(tostring(v),'buffer: ',''),string.gsub(tostring(w),'userdata: ',''),0,0,0,0,0 for G=1,#x do B=bit32.bxor(B,string.byte(x,G))*31 end if coroutine then local G=string.gsub(tostring(coroutine.create(function()end)),'thread: ','')for H=1,#G do C=bit32.bxor(C,string.byte(G,H))*31 end end for G=1,#y do D=bit32.bxor(D,string.byte(y,G))*37 end for G=1,#z do E=bit32.bxor(E,string.byte(z,G))*41 end for G=1,#A do F=bit32.bxor(F,string.byte(A,G))*43 end buffer.writeu32(r,s*16,B)buffer.writeu32(r,s*16+4,C)buffer.writeu32(r,s*16+8,D)buffer.writeu32(r,s*16+12,bit32.bxor(E,F))end WriteToBuffer(r)local function AddExtraEntropy(s,t,u)if not s then return end local v=1024-e if v>0 then local w,x=buffer.len(s)-v,math.min(v,buffer.len(s))if w>0 and t and u then warn(`CSPRNG: {u} returned {w} bytes more than available and was truncated to {x} bytes`)end buffer.copy(d,e,s,0,x)end end for s,t in ad.EntropyProviders do local u=1024-e if u>0 then local v,w=pcall(t,u)if not v then warn(`CSPRNG Provider errored with {w}`)end AddExtraEntropy(w,true,`Entropy Provider #{s}`)end end if ah then AddExtraEntropy(ah,false)end local s=c.Blake3(d,ab+ac)ad.Key=buffer.create(ab)buffer.copy(ad.Key,0,s,0,ab)ad.Nonce=buffer.create(ac)buffer.copy(ad.Nonce,0,s,ab,ac)return buffer.len(d)-e end local function GenerateBlock()buffer.fill(ae,0,0,aa)local ah=c.ChaCha20(ae,ad.Key,ad.Nonce,ad.Counter,20)ad.Buffer=if ad.BlockExpansion then c.Blake3(ah,ag)else ah ad.BufferPosition=0 ad.BufferSize=buffer.len(ad.Buffer)ad.Counter+=1 if ad.Counter%af==0 then GatherEntropy()ad.Counter=0 end end local function GetBytes(ah)local d,e=buffer.create(ah),0 while e<ah do if ad.BufferPosition>=ad.BufferSize then GenerateBlock()end local f,g=ah-e,ad.BufferSize-ad.BufferPosition local h=math.min(f,g)buffer.copy(d,e,ad.Buffer,ad.BufferPosition,h)e+=h ad.BufferPosition+=h end return d end local function GetFloat()if ad.BufferPosition+8>ad.BufferSize then GenerateBlock()end local ah,d=buffer.readu32(ad.Buffer,ad.BufferPosition),buffer.readu32(ad.Buffer,ad.BufferPosition+4)ad.BufferPosition+=8 local e,f=bit32.rshift(ah,5),bit32.rshift(d,6)return(e*67108864+f)/9007199254740992 end local function GetIntRange(ah,d)local e,f=d-ah+1,0xffffffff local g=f-(f%e)if ad.BufferPosition+4>ad.BufferSize then GenerateBlock()end local h=buffer.readu32(ad.Buffer,ad.BufferPosition)ad.BufferPosition+=4 if bit32.band(e,e-1)==0 then return ah+bit32.band(h,e-1)else while h>g do if ad.BufferPosition+4>ad.BufferSize then GenerateBlock()end h=buffer.readu32(ad.Buffer,ad.BufferPosition)ad.BufferPosition+=4 end return ah+(h%e)end end local function GetNumberRange(ah,d)if ah>d then ah,d=d,ah end local e=d-ah if e<=0 then return ah end return ah+(GetFloat()*e)end local function GetRandomString(ah,d)local e=buffer.create(ah)for f=0,ah-1 do buffer.writeu8(e,f,GetIntRange(36,122))end return if d then e else buffer.tostring(e)end local function GetEd25519RandomBytes()local ah=buffer.create(32)for d=0,31 do buffer.writeu8(ah,d,GetIntRange(0,255))end return ah end local function GetEd25519ClampedBytes(ah)local d=buffer.create(32)buffer.copy(d,0,ah,0,32)local e=buffer.readu8(d,0)e=bit32.band(e,0xf8)buffer.writeu8(d,0,e)local f=buffer.readu8(d,31)f=bit32.band(f,0x7f)f=bit32.bor(f,0x40)buffer.writeu8(d,31,f)local g,h=false,buffer.readu8(d,1)for i=2,30 do if buffer.readu8(d,i)~=h then g=true break end end if not g then buffer.writeu8(d,15,bit32.bxor(h,0x55))end return d end function ad.AddEntropyProvider(ah)table.insert(ad.EntropyProviders,ah)end function ad.RemoveEntropyProvider(ah)for d=#ad.EntropyProviders,1,-1 do if ad.EntropyProviders[d]==ah then table.remove(ad.EntropyProviders,d)break end end end function ad.Random()return GetFloat()end function ad.RandomInt(ah,d)if d and type(d)~='number'then error(`Max must be a number or nil, got {typeof(d)}`,2)end if type(ah)~='number'then error(`Min must be a number, got {typeof(ah)}`,2)end if d and d<ah then error(`Max ({d}) can't be less than Min ({ah})`,2)end if d and d==ah then error(`Max ({d}) can't be equal to Min ({ah})`,2)end local e,f if d==nil then e=ah f=1 else e=d f=ah end return GetIntRange(f,e)end function ad.RandomNumber(ah,d)if d and type(d)~='number'then error(`Max must be a number or nil, got {typeof(d)}`,2)end if type(ah)~='number'then error(`Min must be a number, got {typeof(ah)}`,2)end if d and d<ah then error(`Max ({d}) must be bigger than Min ({ah})`,2)end if d and d==ah then error(`Max ({d}) can't be equal to Min ({ah})`,2)end local e,f if d==nil then e=ah f=0 else e=d f=ah end return GetNumberRange(f,e)end function ad.RandomBytes(ah)if type(ah)~='number'then error(`Count must be a number, got {typeof(ah)}`,2)end if ah<=0 then error(`Count must be bigger than 0, got {ah}`,2)end if ah%1~=0 then error('Count must be an integer',2)end return GetBytes(ah)end function ad.RandomString(ah,d)if type(ah)~='number'then error(`Length must be a number, got {typeof(ah)}`,2)end if ah<=0 then error(`Length must be bigger than 0, got {ah}`,2)end if ah%1~=0 then error('Length must be an integer',2)end if d~=nil and type(d)~='boolean'then error(`AsBuffer must be a boolean or nil, got {typeof(d)}`,2)end return GetRandomString(ah,d)end function ad.RandomHex(ah)if type(ah)~='number'then error(`Length must be a number, got {typeof(ah)}`,2)end if ah<=0 then error(`Length must be bigger than 0, got {ah}`,2)end if ah%1~=0 then error('Length must be an integer',2)end if ah%2~=0 then error(`Length must be even, got {ah}`,2)end return GetHexString(ah)end function ad.Ed25519ClampedBytes(ah)if type(ah)~='buffer'then error(`Input must be a buffer, got {typeof(ah)}`,2)end return GetEd25519ClampedBytes(ah)end function ad.Ed25519Random()return GetEd25519ClampedBytes(GetEd25519RandomBytes())end function ad.Reseed(ah)if ah~=nil and type(ah)~='buffer'then error(`CustomEntropy must be a buffer or nil, got {typeof(ah)}`,2)end Reset()GatherEntropy(ah)end ad.BytesLeft=GatherEntropy()GenerateBlock()b.CSPRNG=ad end do local aa,ab,ac,ad,ae,af,ag,ah,d,e,f,g={},buffer.create(131072),buffer.create(65536),buffer.create(65536),buffer.create(8192),buffer.create(2048),buffer.create(65536),buffer.create(65536),buffer.create(65536),{[16]={ExpandedLength=176,MaterialLength=128},[24]={ExpandedLength=208,MaterialLength=160},[32]={ExpandedLength=240,MaterialLength=192}},buffer.create(256),buffer.create(256)do local h,i,j=buffer.create(256),buffer.create(256),buffer.create(256)local function GaloisFieldMultiply(k,l)local m=0 for n=0,7 do if l%2==1 then m=bit32.bxor(m,k)end k=k>=128 and bit32.bxor(k*2%256,27)or k*2%256 l=math.floor(l/2)end return m end local k,l=1,1 buffer.writeu8(f,0,99)for m=1,255 do k=bit32.bxor(k,k*2,k<128 and 0 or 27)%256 l=bit32.bxor(l,l*2)l=bit32.bxor(l,l*4)l=bit32.bxor(l,l*16)%256 if l>=128 then l=bit32.bxor(l,9)end local n=bit32.bxor(l,l%128*2+l/128,l%64*4+l/64,l%32*8+l/32,l%16*16+l/16,99)buffer.writeu8(f,k,n)buffer.writeu8(g,n,k)buffer.writeu8(h,k,GaloisFieldMultiply(3,k))buffer.writeu8(i,k,GaloisFieldMultiply(9,k))buffer.writeu8(j,k,GaloisFieldMultiply(11,k))end local m=0 for n=0,255 do local o=buffer.readu8(f,n)local p,q,r,s=o*256,GaloisFieldMultiply(2,o),GaloisFieldMultiply(13,n),GaloisFieldMultiply(14,n)for t=0,255 do local u=buffer.readu8(f,t)buffer.writeu16(ab,m*2,p+u)buffer.writeu8(ag,m,buffer.readu8(g,bit32.bxor(n,t)))buffer.writeu8(ac,m,bit32.bxor(q,buffer.readu8(h,u)))buffer.writeu8(ad,m,bit32.bxor(o,u))buffer.writeu8(ah,m,bit32.bxor(s,buffer.readu8(j,t)))buffer.writeu8(d,m,bit32.bxor(r,buffer.readu8(i,t)))m+=1 end end end local function ExpandKeySchedule(h,i,j)buffer.copy(j,0,h,0,i)local k,l,m=bit32.rrotate(buffer.readu32(j,i-4),8),0.5,ab if i==32 then for n=32,192,32 do l=l*2%229 local o=buffer.readu16(m,k//65536*2)*65536+buffer.readu16(m,k%65536*2)k=bit32.bxor(buffer.readu32(j,n-32),o,l)buffer.writeu32(j,n,k)local p=bit32.bxor(buffer.readu32(j,n-28),k)buffer.writeu32(j,n+4,p)local q=bit32.bxor(buffer.readu32(j,n-24),p)buffer.writeu32(j,n+8,q)local r=bit32.bxor(buffer.readu32(j,n-20),q)buffer.writeu32(j,n+12,r)o=buffer.readu16(m,r//65536*2)*65536+buffer.readu16(m,r%65536*2)k=bit32.bxor(buffer.readu32(j,n-16),o)buffer.writeu32(j,n+16,k)p=bit32.bxor(buffer.readu32(j,n-12),k)buffer.writeu32(j,n+20,p)q=bit32.bxor(buffer.readu32(j,n-8),p)buffer.writeu32(j,n+24,q)k=bit32.bxor(buffer.readu32(j,n-4),q)buffer.writeu32(j,n+28,k)k=bit32.rrotate(k,8)end local n=buffer.readu16(m,k//65536*2)*65536+buffer.readu16(m,k%65536*2)k=bit32.bxor(buffer.readu32(j,192),n,64)buffer.writeu32(j,224,k)local o=bit32.bxor(buffer.readu32(j,196),k)buffer.writeu32(j,228,o)local p=bit32.bxor(buffer.readu32(j,200),o)buffer.writeu32(j,232,p)buffer.writeu32(j,236,bit32.bxor(buffer.readu32(j,204),p))elseif i==24 then for n=24,168,24 do l=l*2%229 local o=buffer.readu16(m,k//65536*2)*65536+buffer.readu16(m,k%65536*2)k=bit32.bxor(buffer.readu32(j,n-24),o,l)buffer.writeu32(j,n,k)local p=bit32.bxor(buffer.readu32(j,n-20),k)buffer.writeu32(j,n+4,p)local q=bit32.bxor(buffer.readu32(j,n-16),p)buffer.writeu32(j,n+8,q)local r=bit32.bxor(buffer.readu32(j,n-12),q)buffer.writeu32(j,n+12,r)local s=bit32.bxor(buffer.readu32(j,n-8),r)buffer.writeu32(j,n+16,s)k=bit32.bxor(buffer.readu32(j,n-4),s)buffer.writeu32(j,n+20,k)k=bit32.rrotate(k,8)end local n=buffer.readu16(m,k//65536*2)*65536+buffer.readu16(m,k%65536*2)k=bit32.bxor(buffer.readu32(j,168),n,128)buffer.writeu32(j,192,k)local o=bit32.bxor(buffer.readu32(j,172),k)buffer.writeu32(j,196,o)local p=bit32.bxor(buffer.readu32(j,176),o)buffer.writeu32(j,200,p)buffer.writeu32(j,204,bit32.bxor(buffer.readu32(j,180),p))else for n=16,144,16 do l=l*2%229 local o=buffer.readu16(m,k//65536*2)*65536+buffer.readu16(m,k%65536*2)k=bit32.bxor(buffer.readu32(j,n-16),o,l)buffer.writeu32(j,n,k)local p=bit32.bxor(buffer.readu32(j,n-12),k)buffer.writeu32(j,n+4,p)local q=bit32.bxor(buffer.readu32(j,n-8),p)buffer.writeu32(j,n+8,q)k=bit32.bxor(buffer.readu32(j,n-4),q)buffer.writeu32(j,n+12,k)k=bit32.rrotate(k,8)end local n=buffer.readu16(m,k//65536*2)*65536+buffer.readu16(m,k%65536*2)k=bit32.bxor(buffer.readu32(j,144),n,54)buffer.writeu32(j,160,k)local o=bit32.bxor(buffer.readu32(j,148),k)buffer.writeu32(j,164,o)local p=bit32.bxor(buffer.readu32(j,152),o)buffer.writeu32(j,168,p)buffer.writeu32(j,172,bit32.bxor(buffer.readu32(j,156),p))end return j end local h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w local function EncryptBlock(x,y,z,A,B,C)h=bit32.bxor(buffer.readu8(z,A),buffer.readu8(x,0))i=bit32.bxor(buffer.readu8(z,A+1),buffer.readu8(x,1))j=bit32.bxor(buffer.readu8(z,A+2),buffer.readu8(x,2))k=bit32.bxor(buffer.readu8(z,A+3),buffer.readu8(x,3))l=bit32.bxor(buffer.readu8(z,A+4),buffer.readu8(x,4))m=bit32.bxor(buffer.readu8(z,A+5),buffer.readu8(x,5))n=bit32.bxor(buffer.readu8(z,A+6),buffer.readu8(x,6))o=bit32.bxor(buffer.readu8(z,A+7),buffer.readu8(x,7))p=bit32.bxor(buffer.readu8(z,A+8),buffer.readu8(x,8))q=bit32.bxor(buffer.readu8(z,A+9),buffer.readu8(x,9))r=bit32.bxor(buffer.readu8(z,A+10),buffer.readu8(x,10))s=bit32.bxor(buffer.readu8(z,A+11),buffer.readu8(x,11))t=bit32.bxor(buffer.readu8(z,A+12),buffer.readu8(x,12))u=bit32.bxor(buffer.readu8(z,A+13),buffer.readu8(x,13))v=bit32.bxor(buffer.readu8(z,A+14),buffer.readu8(x,14))w=bit32.bxor(buffer.readu8(z,A+15),buffer.readu8(x,15))local D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S=h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w local T,U,V,W,X,Y,Z,_,ai,aj,ak,al,am,an,ao,ap,aq,ar=D*256+I,I*256+N,N*256+S,S*256+D,H*256+M,M*256+R,R*256+G,G*256+H,L*256+Q,Q*256+F,F*256+K,K*256+L,P*256+E,E*256+J,J*256+O,O*256+P,ac,ad for as=16,y,16 do D=bit32.bxor(buffer.readu8(aq,T),buffer.readu8(ar,V),buffer.readu8(x,as))E=bit32.bxor(buffer.readu8(aq,U),buffer.readu8(ar,W),buffer.readu8(x,as+1))F=bit32.bxor(buffer.readu8(aq,V),buffer.readu8(ar,T),buffer.readu8(x,as+2))G=bit32.bxor(buffer.readu8(aq,W),buffer.readu8(ar,U),buffer.readu8(x,as+3))H=bit32.bxor(buffer.readu8(aq,X),buffer.readu8(ar,Z),buffer.readu8(x,as+4))I=bit32.bxor(buffer.readu8(aq,Y),buffer.readu8(ar,_),buffer.readu8(x,as+5))J=bit32.bxor(buffer.readu8(aq,Z),buffer.readu8(ar,X),buffer.readu8(x,as+6))K=bit32.bxor(buffer.readu8(aq,_),buffer.readu8(ar,Y),buffer.readu8(x,as+7))L=bit32.bxor(buffer.readu8(aq,ai),buffer.readu8(ar,ak),buffer.readu8(x,as+8))M=bit32.bxor(buffer.readu8(aq,aj),buffer.readu8(ar,al),buffer.readu8(x,as+9))N=bit32.bxor(buffer.readu8(aq,ak),buffer.readu8(ar,ai),buffer.readu8(x,as+10))O=bit32.bxor(buffer.readu8(aq,al),buffer.readu8(ar,aj),buffer.readu8(x,as+11))P=bit32.bxor(buffer.readu8(aq,am),buffer.readu8(ar,ao),buffer.readu8(x,as+12))Q=bit32.bxor(buffer.readu8(aq,an),buffer.readu8(ar,ap),buffer.readu8(x,as+13))R=bit32.bxor(buffer.readu8(aq,ao),buffer.readu8(ar,am),buffer.readu8(x,as+14))S=bit32.bxor(buffer.readu8(aq,ap),buffer.readu8(ar,an),buffer.readu8(x,as+15))T,U,V,W=D*256+I,I*256+N,N*256+S,S*256+D X,Y,Z,_=H*256+M,M*256+R,R*256+G,G*256+H ai,aj,ak,al=L*256+Q,Q*256+F,F*256+K,K*256+L am,an,ao,ap=P*256+E,E*256+J,J*256+O,O*256+P end buffer.writeu32(B,C,bit32.bxor(buffer.readu16(ab,bit32.bxor(buffer.readu8(aq,ap),buffer.readu8(ad,an),buffer.readu8(x,y+31))*512+bit32.bxor(buffer.readu8(aq,ak),buffer.readu8(ad,ai),buffer.readu8(x,y+26))*2)*65536+buffer.readu16(ab,bit32.bxor(buffer.readu8(aq,Y),buffer.readu8(ad,_),buffer.readu8(x,y+21))*512+bit32.bxor(buffer.readu8(aq,T),buffer.readu8(ad,V),buffer.readu8(x,y+16))*2),buffer.readu32(x,y+32)))buffer.writeu32(B,C+4,bit32.bxor(buffer.readu16(ab,bit32.bxor(buffer.readu8(aq,W),buffer.readu8(ad,U),buffer.readu8(x,y+19))*512+bit32.bxor(buffer.readu8(aq,ao),buffer.readu8(ad,am),buffer.readu8(x,y+30))*2)*65536+buffer.readu16(ab,bit32.bxor(buffer.readu8(aq,aj),buffer.readu8(ad,al),buffer.readu8(x,y+25))*512+bit32.bxor(buffer.readu8(aq,X),buffer.readu8(ad,Z),buffer.readu8(x,y+20))*2),buffer.readu32(x,y+36)))buffer.writeu32(B,C+8,bit32.bxor(buffer.readu16(ab,bit32.bxor(buffer.readu8(aq,_),buffer.readu8(ad,Y),buffer.readu8(x,y+23))*512+bit32.bxor(buffer.readu8(aq,V),buffer.readu8(ad,T),buffer.readu8(x,y+18))*2)*65536+buffer.readu16(ab,bit32.bxor(buffer.readu8(aq,an),buffer.readu8(ad,ap),buffer.readu8(x,y+29))*512+bit32.bxor(buffer.readu8(aq,ai),buffer.readu8(ad,ak),buffer.readu8(x,y+24))*2),buffer.readu32(x,y+40)))buffer.writeu32(B,C+12,bit32.bxor(buffer.readu16(ab,bit32.bxor(buffer.readu8(aq,al),buffer.readu8(ad,aj),buffer.readu8(x,y+27))*512+bit32.bxor(buffer.readu8(aq,Z),buffer.readu8(ad,X),buffer.readu8(x,y+22))*2)*65536+buffer.readu16(ab,bit32.bxor(buffer.readu8(aq,U),buffer.readu8(ad,W),buffer.readu8(x,y+17))*512+bit32.bxor(buffer.readu8(aq,am),buffer.readu8(ad,ao),buffer.readu8(x,y+28))*2),buffer.readu32(x,y+44)))end local function ConstantTimeCompare(ai,aj)local ak,al=buffer.len(ai),buffer.len(aj)if ak~=al then return false end local am=0 for an=0,ak-1 do am=bit32.bor(am,bit32.bxor(buffer.readu8(ai,an),buffer.readu8(aj,an)))end return am==0 end local function BuildShoupTables(ai)local aj,ak=af,ae buffer.copy(aj,0,ai,0,16)for al=1,127 do local am,an=(al-1)*16,al*16 local ao,ap=bit32.band(buffer.readu8(aj,am+15),1),0 for aq=0,15 do local ar=buffer.readu8(aj,am+aq)local as=bit32.lshift(bit32.band(ar,1),7)buffer.writeu8(aj,an+aq,bit32.bor(bit32.rshift(ar,1),ap))ap=as end if ao==1 then buffer.writeu8(aj,an,bit32.bxor(buffer.readu8(aj,an),0xe1))end end for al=0,31 do local am=al*256 buffer.writeu32(ak,am,0)buffer.writeu32(ak,am+4,0)buffer.writeu32(ak,am+8,0)buffer.writeu32(ak,am+12,0)for an=1,15 do local ao,ap,aq,ar,as=am+an*16,0,0,0,0 for x=0,3 do if bit32.band(an,bit32.lshift(1,3-x))~=0 then local y=(al*4+x)*16 ap=bit32.bxor(ap,buffer.readu32(aj,y))aq=bit32.bxor(aq,buffer.readu32(aj,y+4))ar=bit32.bxor(ar,buffer.readu32(aj,y+8))as=bit32.bxor(as,buffer.readu32(aj,y+12))end end buffer.writeu32(ak,ao,ap)buffer.writeu32(ak,ao+4,aq)buffer.writeu32(ak,ao+8,ar)buffer.writeu32(ak,ao+12,as)end end return ak end local function GfMult(ai,aj,ak)local al,am,an,ao=0,0,0,0 for ap=0,15 do local aq,ar=buffer.readu8(ai,ap),ap*512 local as=ar+bit32.rshift(aq,4)*16 al=bit32.bxor(al,buffer.readu32(aj,as))am=bit32.bxor(am,buffer.readu32(aj,as+4))an=bit32.bxor(an,buffer.readu32(aj,as+8))ao=bit32.bxor(ao,buffer.readu32(aj,as+12))local x=ar+256+bit32.band(aq,0xf)*16 al=bit32.bxor(al,buffer.readu32(aj,x))am=bit32.bxor(am,buffer.readu32(aj,x+4))an=bit32.bxor(an,buffer.readu32(aj,x+8))ao=bit32.bxor(ao,buffer.readu32(aj,x+12))end buffer.writeu32(ak,0,al)buffer.writeu32(ak,4,am)buffer.writeu32(ak,8,an)buffer.writeu32(ak,12,ao)end local function Ghash(ai,aj,ak,al)local am,an,ao,ap=math.floor(ak/16),0,buffer.create(16),GfMult for aq=1,am do buffer.writeu32(al,0,bit32.bxor(buffer.readu32(al,0),buffer.readu32(aj,an)))buffer.writeu32(al,4,bit32.bxor(buffer.readu32(al,4),buffer.readu32(aj,an+4)))buffer.writeu32(al,8,bit32.bxor(buffer.readu32(al,8),buffer.readu32(aj,an+8)))buffer.writeu32(al,12,bit32.bxor(buffer.readu32(al,12),buffer.readu32(aj,an+12)))an+=16 ap(al,ai,ao)buffer.writeu32(al,0,buffer.readu32(ao,0))buffer.writeu32(al,4,buffer.readu32(ao,4))buffer.writeu32(al,8,buffer.readu32(ao,8))buffer.writeu32(al,12,buffer.readu32(ao,12))end if an<ak then local aq=ak-an buffer.writeu32(ao,0,0)buffer.writeu32(ao,4,0)buffer.writeu32(ao,8,0)buffer.writeu32(ao,12,0)buffer.copy(ao,0,aj,an,aq)buffer.writeu32(al,0,bit32.bxor(buffer.readu32(al,0),buffer.readu32(ao,0)))buffer.writeu32(al,4,bit32.bxor(buffer.readu32(al,4),buffer.readu32(ao,4)))buffer.writeu32(al,8,bit32.bxor(buffer.readu32(al,8),buffer.readu32(ao,8)))buffer.writeu32(al,12,bit32.bxor(buffer.readu32(al,12),buffer.readu32(ao,12)))ap(al,ai,ao)buffer.writeu32(al,0,buffer.readu32(ao,0))buffer.writeu32(al,4,buffer.readu32(ao,4))buffer.writeu32(al,8,buffer.readu32(ao,8))buffer.writeu32(al,12,buffer.readu32(ao,12))end end local function Gctr(ai,aj,ak,al,am,an)if am==0 then return end local ao,ap,aq,ar,as=math.floor(am/16),buffer.create(16),buffer.create(16),0,0 buffer.writeu32(ap,0,buffer.readu32(ak,0))buffer.writeu32(ap,4,buffer.readu32(ak,4))buffer.writeu32(ap,8,buffer.readu32(ak,8))buffer.writeu32(ap,12,buffer.readu32(ak,12))local x=EncryptBlock for y=0,ao-1 do x(ai,aj,ap,0,aq,0)buffer.writeu32(an,as+0,bit32.bxor(buffer.readu32(al,ar+0),buffer.readu32(aq,0)))buffer.writeu32(an,as+4,bit32.bxor(buffer.readu32(al,ar+4),buffer.readu32(aq,4)))buffer.writeu32(an,as+8,bit32.bxor(buffer.readu32(al,ar+8),buffer.readu32(aq,8)))buffer.writeu32(an,as+12,bit32.bxor(buffer.readu32(al,ar+12),buffer.readu32(aq,12)))ar+=16 as+=16 local z=bit32.byteswap(buffer.readu32(ap,12))z=(z+1)%0x100000000 buffer.writeu32(ap,12,bit32.byteswap(z))end local y=am-ar if y>0 then EncryptBlock(ai,aj,ap,0,aq,0)for z=0,y-1 do local A,B=buffer.readu8(al,ar+z),buffer.readu8(aq,z)buffer.writeu8(an,as+z,bit32.bxor(A,B))end end end local function PrepareJ0(ai,aj,ak,al)local am=BuildShoupTables(ai)if ak==12 then buffer.writeu32(al,0,buffer.readu32(aj,0))buffer.writeu32(al,4,buffer.readu32(aj,4))buffer.writeu32(al,8,buffer.readu32(aj,8))buffer.writeu32(al,12,0x1000000)else buffer.writeu32(al,0,0)buffer.writeu32(al,4,0)buffer.writeu32(al,8,0)buffer.writeu32(al,12,0)Ghash(am,aj,ak,al)local an,ao=buffer.create(16),ak*8 buffer.writeu32(an,0,0)buffer.writeu32(an,4,0)buffer.writeu32(an,8,0)buffer.writeu32(an,12,bit32.byteswap(ao))Ghash(am,an,16,al)end return am end local function GcmGctr(ai,aj,ak,al,am,an)if am==0 then return end local ao=buffer.create(16)buffer.writeu32(ao,0,buffer.readu32(ak,0))buffer.writeu32(ao,4,buffer.readu32(ak,4))buffer.writeu32(ao,8,buffer.readu32(ak,8))buffer.writeu32(ao,12,buffer.readu32(ak,12))local ap=bit32.byteswap(buffer.readu32(ao,12))ap=(ap+1)%0x100000000 buffer.writeu32(ao,12,bit32.byteswap(ap))Gctr(ai,aj,ao,al,am,an)end local function GcmHash(ai,aj,ak,al,am,an)local ao,ap=buffer.create(16),GfMult buffer.writeu32(an,0,0)buffer.writeu32(an,4,0)buffer.writeu32(an,8,0)buffer.writeu32(an,12,0)local aq,ar=math.floor(ak/16),0 for as=1,aq do buffer.writeu32(an,0,bit32.bxor(buffer.readu32(an,0),buffer.readu32(aj,ar)))buffer.writeu32(an,4,bit32.bxor(buffer.readu32(an,4),buffer.readu32(aj,ar+4)))buffer.writeu32(an,8,bit32.bxor(buffer.readu32(an,8),buffer.readu32(aj,ar+8)))buffer.writeu32(an,12,bit32.bxor(buffer.readu32(an,12),buffer.readu32(aj,ar+12)))ar+=16 ap(an,ai,ao)buffer.writeu32(an,0,buffer.readu32(ao,0))buffer.writeu32(an,4,buffer.readu32(ao,4))buffer.writeu32(an,8,buffer.readu32(ao,8))buffer.writeu32(an,12,buffer.readu32(ao,12))end if ar<ak then local as=ak-ar buffer.writeu32(ao,0,0)buffer.writeu32(ao,4,0)buffer.writeu32(ao,8,0)buffer.writeu32(ao,12,0)buffer.copy(ao,0,aj,ar,as)buffer.writeu32(an,0,bit32.bxor(buffer.readu32(an,0),buffer.readu32(ao,0)))buffer.writeu32(an,4,bit32.bxor(buffer.readu32(an,4),buffer.readu32(ao,4)))buffer.writeu32(an,8,bit32.bxor(buffer.readu32(an,8),buffer.readu32(ao,8)))buffer.writeu32(an,12,bit32.bxor(buffer.readu32(an,12),buffer.readu32(ao,12)))ap(an,ai,ao)buffer.writeu32(an,0,buffer.readu32(ao,0))buffer.writeu32(an,4,buffer.readu32(ao,4))buffer.writeu32(an,8,buffer.readu32(ao,8))buffer.writeu32(an,12,buffer.readu32(ao,12))end aq=math.floor(am/16)ar=0 for as=1,aq do buffer.writeu32(an,0,bit32.bxor(buffer.readu32(an,0),buffer.readu32(al,ar)))buffer.writeu32(an,4,bit32.bxor(buffer.readu32(an,4),buffer.readu32(al,ar+4)))buffer.writeu32(an,8,bit32.bxor(buffer.readu32(an,8),buffer.readu32(al,ar+8)))buffer.writeu32(an,12,bit32.bxor(buffer.readu32(an,12),buffer.readu32(al,ar+12)))ar+=16 ap(an,ai,ao)buffer.writeu32(an,0,buffer.readu32(ao,0))buffer.writeu32(an,4,buffer.readu32(ao,4))buffer.writeu32(an,8,buffer.readu32(ao,8))buffer.writeu32(an,12,buffer.readu32(ao,12))end if ar<am then local as=am-ar buffer.writeu32(ao,0,0)buffer.writeu32(ao,4,0)buffer.writeu32(ao,8,0)buffer.writeu32(ao,12,0)buffer.copy(ao,0,al,ar,as)buffer.writeu32(an,0,bit32.bxor(buffer.readu32(an,0),buffer.readu32(ao,0)))buffer.writeu32(an,4,bit32.bxor(buffer.readu32(an,4),buffer.readu32(ao,4)))buffer.writeu32(an,8,bit32.bxor(buffer.readu32(an,8),buffer.readu32(ao,8)))buffer.writeu32(an,12,bit32.bxor(buffer.readu32(an,12),buffer.readu32(ao,12)))ap(an,ai,ao)buffer.writeu32(an,0,buffer.readu32(ao,0))buffer.writeu32(an,4,buffer.readu32(ao,4))buffer.writeu32(an,8,buffer.readu32(ao,8))buffer.writeu32(an,12,buffer.readu32(ao,12))end local as,x=ak*8,am*8 buffer.writeu32(an,4,bit32.bxor(buffer.readu32(an,4),bit32.byteswap(as)))buffer.writeu32(an,12,bit32.bxor(buffer.readu32(an,12),bit32.byteswap(x)))ap(an,ai,ao)buffer.writeu32(an,0,buffer.readu32(ao,0))buffer.writeu32(an,4,buffer.readu32(ao,4))buffer.writeu32(an,8,buffer.readu32(ao,8))buffer.writeu32(an,12,buffer.readu32(ao,12))end function aa.Encrypt(ai,aj,ak,al)if not aj or typeof(aj)~='buffer'then error('Key must be a buffer',2)end if not ak or typeof(ak)~='buffer'then error('IV must be a buffer',2)end if not ai or typeof(ai)~='buffer'then error('Plaintext must be a buffer',2)end local am=buffer.len(aj)if am~=16 and am~=24 and am~=32 then error('Key must be 16, 24, or 32 bytes',2)end local an=e[am]local ao,ap,aq,ar,as,x=ExpandKeySchedule(aj,am,buffer.create(an.ExpandedLength)),an.MaterialLength,buffer.len(ak),buffer.len(al or buffer.create(0)),buffer.len(ai),al or buffer.create(0)local y,z,A,B,C=buffer.create(as),buffer.create(16),buffer.create(16),buffer.create(16),buffer.create(16)EncryptBlock(ao,ap,A,0,A,0)local D=PrepareJ0(A,ak,aq,B)GcmGctr(ao,ap,B,ai,as,y)GcmHash(D,x,ar,y,as,C)Gctr(ao,ap,B,C,16,z)return y,z end function aa.Decrypt(ai,aj,ak,al,am)if not aj or typeof(aj)~='buffer'then error('Key must be a buffer',2)end if not ak or typeof(ak)~='buffer'then error('IV must be a buffer',2)end if not ai or typeof(ai)~='buffer'then error('Ciphertext must be a buffer',2)end if not al or typeof(al)~='buffer'then error('Tag must be a buffer',2)end local an=buffer.len(aj)if an~=16 and an~=24 and an~=32 then error('Key must be 16, 24, or 32 bytes',2)end local ao=e[an]local ap,aq,ar,as,x,y=ExpandKeySchedule(aj,an,buffer.create(ao.ExpandedLength)),ao.MaterialLength,buffer.len(ak),buffer.len(am or buffer.create(0)),buffer.len(ai),am or buffer.create(0)local z,A,B,C,D=buffer.create(x),buffer.create(16),buffer.create(16),buffer.create(16),buffer.create(16)EncryptBlock(ap,aq,A,0,A,0)local E=PrepareJ0(A,ak,ar,B)GcmGctr(ap,aq,B,ai,x,z)GcmHash(E,y,as,ai,x,C)Gctr(ap,aq,B,C,16,D)if not ConstantTimeCompare(al,D)then return false,nil end return true,z end a.AES=aa end local aa={Encryption=a,Funcs=c,Utils=b}return table.freeze(aa)